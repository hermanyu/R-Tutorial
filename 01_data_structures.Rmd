# What's Your Vector, Victor?

## 3. Basic Data Structures

In order to perform more complicated processes, we must organize our data into more sophisticated constructs. This section will cover some of the basic data structures that come equipped in base R. Specifically, we will talk about the following class of objects:

1.  Vectors
2.  Lists
3.  Matrices
4.  Arrays
5.  Data Frames

\

### 3.1 Vectors

\

#### 3.1.1 Building Vectors

A **vector** is just a sequence of values, all of the same data type. To build a vector, we use the syntax `c()` and input the vector components.

```{r}
# define a vector [1,2,3] and call it v
v <- c(1,2,3)

# print the vector v
print(v)
```

\

As mentioned in the section on loops, vectors are `iterable` and so we can use their components to index `for` loops.

```{r}
for (component in v){
  cat("component... ", component, "\n")
}
```

\

Unlike in math, vectors are not restricted to numeric values. We can have a vector of `characters` and a vector of `logicals` as well:

```{r}
# define a vector of characters
s <- c("a", "b", "cee", "d")

# define a vector of logicals (booleans)
bool <- c(TRUE, TRUE, FALSE, TRUE, FALSE)

print(s)
print(bool)
```

\

Since the components of a vector are all the same typing, every vector inherits a typing from its components:

```{r}
# a vector of type "double"
v <- c(1,2,3)

# a vector of type "character"
s <- c("a", "b", "cee")

# a vector of type "logical"
bool <- c(TRUE, FALSE, FALSE)

typeof(v)
typeof(s)
typeof(bool)
```

\

We can also construct vectors with sequential values using the `:` operation

```{r}
# generate a vector whose values are 1, 2, 3, 4, ..., 100
nums <- 1:100

print(nums)
```

\

We can also customize the sequencing a bit more using the `seq()` function

```{r}
# generate a vector whose values are 10, 20, 30, 40, ..., 500
tens <- seq(from = 0, to = 500, by=10)

print(tens)
```

\

#### 3.1.2 Accessing Vector Components

The purpose of any data structure is to organize data in a useful way. The end goal of every data structure is to provide a utilitarian way to store and retrieve data. Vectors are no exception; Utilizing vectors to their fullest requires understanding how to store and retrieve data from them.

The **components** of a vector are the individual values stored in the vector. To store values in a vector, we simply construct a new vector like we did before:

```{r}
# store the values 2, 4, and 6 in a vector
v <- c(2,4,6,8,10)

print(v)
```

\

**Accessing** the components of a vector means to retrieve the value from the vector. Recall that data structures are built to organize data in a useful way. Vectors are specifically built to organize data as sequence of values. Therefore, each value in a vector can be identified by its **index**, i.e. its place in line.

```{r}
# Access the 3rd element of the vector v = (2,4,6,8,10)
v[3]
```

\

We can store new values at specific indices too. This overwriting the previous value.

```{r}
# store the value -2 in the 1st position 
v[1] <- -2

print(v)
```

\

Sometimes, we will want to store a new value without overwriting any of the previous values. This can be done by adjoining the new value at the tail-end.

```{r}
append(v, 12)
```

This is probably a good time to point out a major difference between Python and R. In Python, `append()` is called as a method to a list, hence it changes the original list on which it is called.

In R, `append()` is a function which takes `v` and `12` as inputs and returns a *new* vector object $[-2, 4, 6, 8, 10, 12]$. Therefore, the original vector `v` does not get changed. Consequently, if we wanted to use the new vector $[-2,4,6,8,10]$, we will need to tie it down with a variable:

```{r}
# append 12 to v and store it in a new variable
new_v <- append(v,12)

# notice that the original vector v is unchanged
print(v)
print(new_v)
```

\

We can also access multiple values by passing a "vector of indices":

```{r}
# access the 1st, 2nd and 5th values in the vector v
v[c(1,2,5)]



# to be more explicit, we can specify the desired index values
# by building an "access" vector
access_vector = c(1,2,5)

# then use access_vector to access the components of v by indices
v[access_vector]
```

\

#### 3.1.3 Vector Operations

\

##### Arithmetic Operations

We can do arithmetic on *numeric* vectors (like how we would do arithmetic with numbers)

```{r}
# define 2 vectors
v <- c(2,2,2)
u <- c(6,4,2)

# vector addition
v + u

# vector subtraction
v - u

# elementwise multiplication (aka the Hadamard product)
v*u

# elementwise division
u/v
```

\

We can also take the "absolute value" aka the magnitude (aka the norm) of vectors as well. Mathematically, the **(Euclidean) norm** of a vector $v = (v_1,\ldots,v_n)$ is given by the formula: $$|(v_1,\ldots,v_n)| = \sqrt{\sum_{i=1}^n v_i^2} = \sqrt{v_1^2+\ldots+v_n^2}$$

```{r}

norm(v, type="2")
norm(u, type="2")
```

**Fun Math Fact:** when making examples of norms for 3D vectors, the author (i.e. me!) found it very hard to find nice, whole integer values for the vector and its norm. In fact, the only 3D vectors whose components *and* norms are whole integer values are `c(0,0,0)` and `c(1,1,1)`. No other vector can have integer components and an integer norm. This result is known as **Fermat's Last Theorem** and was conjectured by Pierre Fermat in the 1600s. Mathematicians failed to prove it for over 300 years until Andrew Wiles finally came up with an answer in 1991.

\

**Fun Math + Programming Fact:** it turns out that the `norm()` function actually computes norms for `matrix` objects. The parameter value `type="2"` specificies the "2-norm" or the **spectral norm**. As implied by the name, the spectral norm returns the largest value of the "spectrum" aka the largest **singular value** of the "matrix" $v$. Note that singular values of any matrix $A$ are just the square-roots of the eigenvalues of $AA^T$. For our row vector $v$ (being treated as a $1\times 3$ matrix), the largest singular value of $v$ is thus the square-root of the largest eigenvalue of $vv^T = |v|^2$. Now $|v|^2$ is a scalar, so its eigenvalue is just itself $|v|^2$, hence the singular value of $v$ is precisely just $\sqrt{|v|^2} = |v|$. **This is why using the `norm()` function actually results in the Euclidean norm for row vectors in the R language**. That being said, R is computing this norm by doing an **SVD** (singular value decomposition) every time, so the run time can become quite problematic when the vector dimensions are large. A more runtime efficient way to compute norms is to hard code the formula into a function. However, the catch is that hard coding the formula can lead to under/overflow issues in the sum of squares.

\

##### Sorting

Vectors store data and we can manipulate how that data is stored (to a certain extent). One such manipulation is the `sort()` operation, which sorts the values of the vector

```{r}
# define a vector
v <- c(5, 17, -4, 16, 8)

# sort vector in ascending/increasing order
sort(v)

# sort vector in descending/decreasing order
sort(v, decreasing=TRUE)
```

\

**Programming Note:** one of the first problems encountered in a Data Structures and Algorithms class is the Sorting Problem. The problem is to write an algorithm which sorts a list of numbers from smallest to largest. The challenge to the problem lies in writing an algorithm that performs the sorting as fast as possible. Many different algorithms have been devised: insertion sort, merge sort, bubble sort, quick sort, etc. The `sort()` function in R comes with a `method` parameter where we can choose to use a specific sorting algorithm to carry out the sorting process. The possible values we can choose are: `auto` (R picks for us), `shell` (shell sort), `quick` (quick sort) and `radix` (radix sort).

```{r}
# sort the vector v using shell sort
sort(v, method="shell")
```

\

##### Logical Operations

Recall that our `logical` values `TRUE` and `FALSE` had the `&` (AND), `|` (OR) and `!` (NOT) operations. Since vectors can be of `logical` type, these operations extend seamlessly to `logical` vectors as well:

```{r}
# construct 2 vectors of logical type
bool1 <- c(TRUE, FALSE, FALSE)
bool2 <- c(TRUE, TRUE, FALSE)

# AND operator; performs the '&' operation element-wise
bool1 & bool2

# OR operator; performs the '|' operation element-wise
bool1 | bool2

# NOT operator; performs the '!' operation element-wise
!bool1
```

\

### 3.2 Lists

A **list** is a sequential collection of data values, which can be of varying type. The key defining phrase here is "data values of varying type" which distinguishes lists from vectors.

\

#### 3.2.1 Constructing Lists and Accessing Elements

To construct a list, we use the following syntax:

```{r}
# construct a list of ML models
my_list <- list("XGBoost", "Random Forest", "Cubic Spline", "LSTM")

my_list

# lists can store data values of various types
academic_record <- list("A", "B-", 3.5, "A+", "A", "B", 3.66, TRUE)

academic_record
```

\

**Note:** Unlike vectors, lists get printed out 1 element at a time to the console. This significantly hampers readability, especially for large lists. We want to print the elements of a list as compactly as possible. One option that slightly helps is that `str()` function (short for "structure").

```{r}
# compactly displays the structure of an arbitrary object, e.g. a list
str(my_list)
```
\

However, this is still not ideal especially for longer lists. For this reason, we generally will default to using **vectors** when building a sequential collection of objects of the same type. However for the purposes of demonstration, we coerce ourselves into using lists for rest of the section.

\

Since lists are sequential (like vectors), we can access data in lists by specifying an index position.

```{r}
my_list <- list("XGBoost", "Random Forest", "Cubic Spline", "LSTM")

# retrieve 2nd element of my_list
my_list[2]
```

```{r}
# overwrite 2nd element of my list
my_list[2] <- "Support Vector Machine"

str(my_list)
```

\

#### 3.2.3 Look Ups

Lists and vectors are just a collection of elements organized in a certain way. Therefore, we can ask the question: "Is value `x` contained inside the list?" We can answer this question using the `%in%` operator:

```{r}
# check to see if the value "Cubic Spline" is in my_list
"Cubic Spline" %in% my_list
"K-Nearest Neighbors" %in% my_list

# create a vector v and look up a value
v <- c(10,-10, 34, 17, -30, 5,-6, -2)

-6 %in% v
```

**Note:** Look up times for `%in%` can become inefficient for larger lists and vectors, as discussed in <a href='https://stackoverflow.com/questions/33453141/most-efficient-way-to-determine-if-element-exists-in-a-vector'> this stack overflow post </a>. It might be more efficient write custom search algorithms (e.g. binary search) for large lists and vectors.

\

#### 3.2.4 Infix Operators

Now might be a good time to discuss **infix operators** in R. Looking back at the operations we've seen, we may notice a few of them follow a similar syntactic form:

1.  `%%` modular divison.
2.  `%/%` floor division.
3.  `%in%` membership check.

The commonality here is the form `% ... %` of these operators. These operators are called **infix operators** and they are functions where you can call them as a symbolic operation between two elements.

For example, consider the following two ways to add up numbers:

```{r}
# defining an ordinary function
plus <- function(x,y){
  return(x+y)
}

# defining an infix operator
"%plus%" <- function(x,y){
  return(x+y)
}
```

\

Both functions are defined the same way and will do the same thing. However, the difference lies in the *syntax in which they are called*.

```{r}
plus(2,3)

2 %plus% 3
```

Notice that syntax of the second function `2 %plus% 3` is more in-line with how we (humans) usually read and write mathematical operations. This is what an "infix" operator is.

Defining an infix operator is as simple as using the syntax `"% <operator name> %"`. For example, here is an infix operator that concatenates strings:

```{r}
# define new infix operator for string concatenation
"%--%" <- function(string_1, string_2){
  return(paste0(string_1,string_2))
}

# concatenate some strings!
"Hello" %--% "," %--% " world!"
```

\

We should be careful here and mention that R comes with some pre-defined infix operators. They are:

-   `%%` modular divisioin.
-   `%/%` floor division.
-   `%in%` membership check.
-   `%o%` outer product.
-   `%*%` matrix multiplication.
-   `%x%` Kronecker product.

```{r}
v <- c(1,2,3)
u <- c(2,5,10)

# take outer product of v and u
v %o% u
```
\

#### 3.2.5 Inserting and Removing List Items

We can insert and remove items from lists, which allow us to dynamically control the contents of a list in real-time.

##### Insert / Append

To insert elements into a list, we can use the `append()` function:

```{r}
my_list <- list("XGBoost", "Random Forest", "Cubic Spline", "LSTM")

# insert/append an item after the 3rd element in the list
my_list2 <- append(my_list, "CNN", after=3)

str(my_list2)

# If no index specified, insertion defaults to end of list
my_list3 <- append(my_list, "Transformer")

str(my_list3)
```
\

This also works for vectors too:

```{r}
# define a vector of numerics
v <- c(-1,1,3,10)

# append a the element 117 to vector v, after 2nd to last index
new_v <- append(v, 117, after=length(v)-1)

new_v
```
\

##### Removal

Items can be removed from lists and vectors using **negative indices**. 

```{r}
my_list <- list("XGBoost", "Random Forest", "Cubic Spline", "LSTM")

# remove the 3rd item from the list
my_list <- my_list[-3]

str(my_list)
```
\

```{r}
v <- c(-1,1,3,10)

# remove 2nd item from vector v
v <- v[-2]

str(v)

```

**WARNING:** This syntax in R can be quite confusing for someone (e.g. me!) migrating over from Python. In Python, negative indices indicate *reverse ordering*, e.g. `my_list[-3]` means "the 3rd element from the back of the list." This might take some getting use to especially when it comes to subsetting and slicing.

\

#### 3.2.6 Subsetting and Slicing

When we remove an element from a list, e.g. `my_list[-2]`, what we are actually doing is **subsetting** the original list. That is, we are taking a subset of elements from the original list which meets a certain condition. In the case `my_list[-2]`, we are subsetting all elements except the one at index 2.

This generalizes quite nicely in R by using a *vector of indices*:

```{r}
my_list <- list("XGBoost", "Random Forest", "Cubic Spline", "LSTM")

# subset the 1st and 3rd element of my_list
my_list[c(1,3)]
```
\

Another way to subset a list/vector is **slicing**. This simply returns a contiguous chunk of the list/vector, like so:

```{r}
long_list <- list("XGBoost", "AdaBoost", "Random Forest", "Support Vector Maching", "Logistic Regression", "DBScan", "Cubic Spline", "CNN", "LSTM", "Transfromer")

# Return a "slice" of the list, from the 3rd element to the 8th element
slice <- long_list[3:8]

str(slice)
```
\

#### 3.2.7 Nested Lists

One final idea on lists is the concept of **nested lists**. A list is just a collection of objects of possibly many different types. In particular, *a list can store other lists*. Here is an example:

```{r}
# create a list of linear models
linear_models <- list("Linear Regression", "Polynomial Regression", "Logistic Regression", "Support Vector Machine", "Low-Rank Matrix Factorization")

# create a list of tree-based models
tree_models <- list("Decision Tree", "Bagged Trees", "Random Forest", "AdaBoost", "XGBoost")

# create a list of deep learning models
deep_learning_models <- list("Artifical Neural Netwwork", "Convolutional Neural Network", "GRU", "LSTM", "GAN", "VAE", "Transformer")

# create a list of some other models
misc <- list("Naive Bayes", "K-Means Clustering", "DBSCAN", "K-Nearest Neighbors", "PCA")

# create a list of some of the tools for data science
toolbox <- list(linear_models, tree_models, deep_learning_models, misc)

str(toolbox)
```
\

The first question we need to answer: "How do we access elements in a nested list?" The answer is to use double brackets`[[ ]]` to specify the outside top-level index, then single brackets `[ ]` to specify the second level index:

```{r}
# get the element located in the 2nd list, 4th position
toolbox[[2]][4]
```
\

Alternatively, what we could have done instead was assign a **name** to each component of the list. Unsurprisingly, lists with named components are called **named lists**.

```{r}
# re-create the list "toolbox" as a named list
toolbox <- list(
  "linear models" = list(
    "Linear Regression", "Polynomial Regression", "Logistic Regression", 
    "Support Vector Machine", "Low-Rank Matrix Factorization"
  ),
  "tree models" = list(
    "Decision Tree", "Bagged Trees", "Random Forest", "AdaBoost", "XGBoost"
  ),
  "deep learning models" = list(
    "Artifical Neural Netwwork", "Convolutional Neural Network", "GRU", "LSTM",
    "GAN", "VAE", "Transformer"
  ),
  "misc" = list(
    "Naive Bayes", "K-Means Clustering", "DBSCAN", "K-Nearest Neighbors", "PCA"
  )
)
```
\

Why would we want to create a named list? One advantage is that the components can be *referenced by their names*!

```{r}
subset = toolbox[c("linear models", "misc")]

str(subset)
```
\

The syntax for accessing elements is also identical to reguar nested lists:

```{r}
toolbox[['tree models']][3]
```
\

There might be times where we want to add a naming convention to a pre-constructed list. We can do this by calling the `name()` function on the pre-constructed list:

```{r}
# create a list with no named components
model_info <- list(8, 3200, 0.73, 1.04)

# add names to components post-hoc; names are given by a vector of strings
names(model_info) <- c("layers", "number of weights", "training loss", "validation loss")

str(model_info)
```
\

#### 3.2.8 lapply()

There will be times where we want to apply a single function onto every element of a list or vector. Consider the following example:

```{r}
# create a list of pet types
pets <- c("cat", "dog", "hamster", "turtle")

```
\

Let's say we want to write a program which allows a user to add a color descriptor to each pet. We can start by writing a function that adds a `color` string to each `pet` string:

```{r}
# create a function that adds a color in the front of a pet type
add_color <- function(color, pet){
  return(paste(color, pet))
}

# test function behavior
add_color("black", "cat")
```
\

We need to apply this function to every element of the `pets` vector. One way to accomplish this is to use a `for` loop:

```{r}
# fix a user selected color
color_selection = "brown"

# create an empty list to store the new pet strings
brown_pets <- c()

# add color_selection to every pet in the pets vector
for (pet in pets){
  new_pet <- add_color("brown", pet)
  brown_pets <- append(brown_pets, new_pet)
}

brown_pets
```
\

The `lapply()` function accomplishes all of this in a more concise way:

```{r}
brown_pets2 <- lapply(pets, add_color, color="brown")

brown_pets2
```
\

**Note:** the `lapply()` function always returns a list. If we wanted the output to be the same typing as the inputted data structure (e.g. a vector), we can use the `sapply()` function. `sapply()` is a wrapper for `lapply()` that preserves the type from input to output.

```{r}
brown_pets3 <- sapply(pets, add_color, color="brown", USE.NAMES=FALSE)

brown_pets3
```
\

#### 3.2.9 Joining Lists

We can concatenate two lists by casting both lists as components of a vector:

```{r}
list_A <- list("Microsoft", "Apple", "Google", "Nvidia")
list_B <- list("Amazon", "Spotify", "Netflix", "Facebook")

list_total <- c(list_A, list_B)

str(list_total)
```
\

\

---
